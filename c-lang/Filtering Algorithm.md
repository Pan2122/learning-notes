
---

# 📚 嵌入式滤波算法学习笔记 (STM32/ESP32 专用版)

## 🎯 第一部分：基础滤波算法 (常用三剑客)

在嵌入式开发中，针对单一传感器数据的简单处理，通常使用以下三种算法。它们资源占用极小，适合处理特定类型的噪声。

### 1. 算术平均滤波 (Arithmetic Mean Filter)

* **核心原理**：连续采集 `N` 个数据，求和并除以 `N`。
* **适用场景**：信号平稳，但存在**随机小幅度波动**（高频白噪声）。
* *例子*：室温测量、水箱液位检测。


* **优缺点**：
* ✅ 平滑度高。
* ❌ 灵敏度低，对突变反应慢；无法消除明显的脉冲干扰。



### 2. 中值滤波 (Median Filter)

* **核心原理**：采集 `N` 个数据（通常为奇数），排序后取**中间值**。
* **适用场景**：对抗**脉冲噪声**（偶然出现的极大/极小异常值）。
* *例子*：超声波测距（偶尔跳变到 500cm）、红外传感器受阳光直射干扰。


* **优缺点**：
* ✅ 能完美过滤掉偶然的“捣乱值”，不影响真实数据。
* ❌ 计算量稍大（涉及到排序算法），只适合采样率不高的场景。



### 3. 一阶滞后滤波 (First-Order Lag / Low Pass Filter)

* **核心原理**：利用“惯性”思想，给新旧数据分配权重。相当于软件层面的 RC 低通滤波。
* **公式**：
```c
本次输出 = α * 本次采样值 + (1 - α) * 上次输出

```


* **参数说明**：`α` (Alpha) 是滤波系数，范围在 0 到 1 之间。
* `α` 越小：惯性越大，波形越平滑，但**滞后越严重**。
* `α` 越大：跟随性越好，但**平滑效果变差**。




* **适用场景**：**实时性要求较高**，且需要抑制高频抖动的场景。
* *例子*：平衡小车加速度采样、电机速度反馈。


* **优缺点**：
* ✅ **内存占用极小**（不需要存历史数组，只需存上一次结果）；运算速度快。
* ❌ 存在相位滞后。



---

## 🌟 第二部分：卡尔曼滤波 (Kalman Filter) —— 重点复盘

卡尔曼滤波不仅仅是“滤波”，它本质上是一个**最优状态估计器 (Optimal Estimator)**。它的核心价值在于**融合**和**预测**。

### 1. 为什么它是嵌入式“顶流”？

1. **递归特性 (Recursive)**：它不需要存储过去几百次的历史数据，只需要知道“上一次的状态”就能算出“这一次的状态”。这对内存有限的 STM32/ESP32 极其友好。
2. **传感器融合 (Sensor Fusion)**：它能结合多个传感器（如加速度计+陀螺仪）的优点，取长补短。
3. **动态调整**：它能根据系统的协方差（噪声水平）自动调整信任权重。

### 2. 核心机制：预测 + 修正

卡尔曼滤波永远在做两件事的无限循环：

#### A. 预测 (Predict) —— "闭眼猜"

* **依据**：物理模型（如：路程 = 速度 × 时间）。
* **行为**：根据上一时刻的状态，推算当前时刻的状态。
* **IMU 例子**：根据陀螺仪的角速度积分，推算现在的角度。
* **公式**：
```c
预测角度 = 上次角度 + (角速度 - 零漂) * dt

```




* **特点**：短时间内很准，但时间长了会有累积误差（漂移）。

#### B. 修正 (Update) —— "睁眼看"

* **依据**：测量仪器（传感器实测值）。
* **行为**：读取传感器数据，计算它与预测值的偏差，然后根据**卡尔曼增益 (K)** 进行修正。
* **IMU 例子**：读取加速度计计算出的角度，用来纠正陀螺仪的漂移。
* **关键逻辑**：
* 如果 **模型更可信**（Q 参数小），K 值变小 -> **系统更加相信预测值**。
* 如果 **传感器更可信**（R 参数小），K 值变大 -> **系统更加相信实测值**。



---

## ⚔️ 第三部分：DMP (硬件) vs. 软件卡尔曼

在 MPU6050 等传感器应用中，这是一个经典的选择题。

| 特性 | DMP (Digital Motion Processor) | 软件卡尔曼 (Software Kalman) |
| --- | --- | --- |
| **本质** | **硬解**：传感器内部集成的微处理器直接算 | **软解**：STM32 代码里自己写算法算 |
| **输出** | 四元数 (Quaternion)，可转欧拉角 | 欧拉角 (Pitch/Roll)，通常仅做单轴或双轴 |
| **优点** | **不占 STM32 资源**；无万向节死锁；波形极其平滑 | **完全可控**（可调参）；**采样率极高**（>1kHz）；响应极快 |
| **缺点** | “黑盒子”无法修改；采样率受限 (100/200Hz)；有缓慢漂移 | 占用单片机算力；需要理解数学原理 |
| **适用** | 3D 空中飞鼠、低端单片机、不需要极速响应的场景 | **平衡小车**、倒立摆、穿越机（需要毫秒级响应控制） |

---

## 💻 第四部分：代码实现逻辑复盘 (C语言版)

一个针对平衡小车的简化版一维卡尔曼滤波结构：

```c
typedef struct {
    float angle;      // 【核心】最终输出角度
    float gyro_bias;  // 【核心】自动估算的陀螺仪零漂
    float P[2][2];    // 状态协方差矩阵（表示不确定度）
    float Q_angle;    // 参数：角度过程噪声（相信模型程度）
    float Q_gyro;     // 参数：漂移过程噪声
    float R_angle;    // 参数：测量噪声（相信传感器程度）
} Kalman_t;

```

**核心步骤图解：**

1. **先预测 (Predict)**：
```c
// 利用陀螺仪积分，先猜一个角度
angle += (gyro - bias) * dt;

```


2. **算偏差 (Innovation)**：
```c
// 看看猜的和平时用的加速度计差多少
err = accel_angle - angle;

```


3. **算增益 (K)**：
```c
// 根据当前的信任度 P 和传感器噪声 R，决定这次修正力度多大
K = P / (P + R);

```


4. **后修正 (Update)**：
```c
// 修正角度
angle += K * err;

// 顺便把陀螺仪的零点漂移也修正了！这是互补滤波做不到的
bias += K_bias * err;

```



---

## 💡 思考 ( Tips)

1. **调参直觉**：
* 调参时，如果发现**波形滞后太严重**（反应慢半拍），说明过于信任预测，或者 R 值设置得太大了。
* 如果**波形毛刺太多**（震动明显），说明过于信任传感器，或者 R 值设置得太小了。


2. **底层数据操作**：
* 在写驱动时，时刻注意你是操作 **指针 (`->`)** 还是操作 **变量 (`.`)**。
* **指针 (`->`)**：修改的是内存里的**真身**。
* **变量 (`.`)**：修改的往往只是复制出来的**替身**。



---