
---

# 📚 嵌入式滤波算法学习笔记 (STM32/ESP32)

## 🎯 第一部分：基础滤波算法 (常用三剑客)

在嵌入式开发中，针对单一传感器数据的简单处理，通常使用以下三种算法。它们资源占用极小，适合处理特定类型的噪声。

### 1. 算术平均滤波 (Arithmetic Mean Filter)

* **核心原理**：连续采集  个数据，求和并除以 。
* **适用场景**：信号平稳，但存在**随机小幅度波动**（高频白噪声）。
* *例子*：室温测量、水箱液位检测。


* **优缺点**：
* ✅ 平滑度高。
* ❌ 灵敏度低，对突变反应慢；无法消除明显的脉冲干扰。



### 2. 中值滤波 (Median Filter)

* **核心原理**：采集  个数据（通常为奇数），排序后取**中间值**。
* **适用场景**：对抗**脉冲噪声**（偶然出现的极大/极小异常值）。
* *例子*：超声波测距（偶尔跳变到 500cm）、红外传感器受阳光干扰。


* **优缺点**：
* ✅ 能完美过滤掉偶然的“捣乱值”，不影响真实数据。
* ❌ 计算量稍大（涉及到排序算法），只适合采样率不高的场景。



### 3. 一阶滞后滤波 (First-Order Lag / Low Pass Filter)

* **核心原理**：利用“惯性”思想，给新旧数据分配权重。
* 
*  为滤波系数 ()。 越小，惯性越大，波形越平滑，但滞后越严重。


* **适用场景**：**实时性要求较高**，且需要抑制高频抖动的场景。
* *例子*：平衡小车加速度采样、电机速度反馈。


* **优缺点**：
* ✅ **内存占用极小**（不需要存历史数组，只需存上一次结果）；运算速度快。
* ❌ 存在相位滞后（这也是“滞后滤波”名字的由来）。



---

## 🌟 第二部分：卡尔曼滤波 (Kalman Filter) —— 重点复盘

卡尔曼滤波不仅仅是“滤波”，它本质上是一个**最优状态估计器 (Optimal Estimator)**。它的核心价值在于**融合**和**预测**。

### 1. 为什么它是嵌入式“顶流”？

1. **递归特性 (Recursive)**：它不需要存储过去几百次的历史数据，只需要知道“上一次的状态”就能算出“这一次的状态”。这对内存有限的 STM32/ESP32 极其友好。
2. **传感器融合 (Sensor Fusion)**：它能结合多个传感器（如加速度计+陀螺仪）的优点，取长补短。
3. **动态调整**：它能根据系统的协方差（噪声水平）自动调整信任权重。

### 2. 核心机制：预测 + 修正

卡尔曼滤波永远在做两件事的无限循环：

#### A. 预测 (Predict) —— "闭眼猜"

* **依据**：物理模型（如：路程 = 速度 × 时间）。
* **行为**：根据上一时刻的状态，推算当前时刻的状态。
* **IMU 例子**：根据陀螺仪的角速度积分，推算现在的角度。
* 


* **特点**：短时间内很准，但时间长了会有累积误差（漂移）。

#### B. 修正 (Update) —— "睁眼看"

* **依据**：测量仪器（传感器实测值）。
* **行为**：读取传感器数据，计算它与预测值的偏差，然后根据**卡尔曼增益 (K)** 进行修正。
* **IMU 例子**：读取加速度计计算出的角度，用来纠正陀螺仪的漂移。
* **关键逻辑**：
* 如果 **模型更可信**（ 小）， 值变小  更加相信预测值。
* 如果 **传感器更可信**（ 小）， 值变大  更加相信实测值。



### 3. DMP (硬件) vs. 软件卡尔曼

在 MPU6050 等传感器应用中，这是一个经典的选择题。

| 特性 | DMP (Digital Motion Processor) | 软件卡尔曼 (Software Kalman) |
| --- | --- | --- |
| **本质** | **硬解**：传感器内部集成的微处理器直接算 | **软解**：STM32 代码里自己写算法算 |
| **输出** | 四元数 (Quaternion)，可转欧拉角 | 欧拉角 (Pitch/Roll)，通常仅做单轴或双轴 |
| **优点** | **不占 STM32 资源**；无万向节死锁；波形极其平滑 | **完全可控**（可调参）；**采样率极高**（>1kHz）；响应极快 |
| **缺点** | “黑盒子”无法修改；采样率受限 (100/200Hz)；有缓慢漂移 | 占用单片机算力；需要理解数学原理 |
| **适用** | 3D 空中飞鼠、低端单片机、不需要极速响应的场景 | **平衡小车**、倒立摆、穿越机（需要毫秒级响应控制） |

---

### 4. 代码实现逻辑复盘 (C语言版)

一个针对平衡小车的简化版一维卡尔曼滤波结构：

```c
typedef struct {
    float angle;      // 【核心】最终输出角度
    float gyro_bias;  // 【核心】自动估算的陀螺仪零漂
    float P[2][2];    // 状态协方差矩阵（表示不确定度）
    float Q_angle;    // 参数：角度过程噪声（相信模型程度）
    float Q_gyro;     // 参数：漂移过程噪声
    float R_angle;    // 参数：测量噪声（相信传感器程度）
} Kalman_t;

```

**核心步骤图解：**

1. **先预测**：
`angle += (gyro - bias) * dt;`
*(利用陀螺仪积分，先猜一个角度)*
2. **算偏差**：
`err = accel_angle - angle;`
*(看看猜的和平时用的加速度计差多少)*
3. **算增益 (K)**：
`K = P / (P + R);`
*(根据当前的信任度 P 和传感器噪声 R，决定这次修正力度多大)*
4. **后修正**：
`angle += K * err;`
*(修正角度)*
`bias += K_bias * err;`
*(顺便把陀螺仪的零点漂移也修正了！这是互补滤波做不到的)*

---

### 💡补充思考

* **调参经验**：调参时，如果发现波形滞后太严重，说明过于信任预测（或 R 太大）；如果波形毛刺太多，说明过于信任传感器（R 太小）。
* **数据类型**：在底层驱动中，时刻注意你是操作**指针 (`->`)** 还是操作**变量 (`.`)**，这决定了你是修改了原始数据还是只修改了副本。

---
😄