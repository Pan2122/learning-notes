---
layout: doc
title: 旋转编码器：从原理到实战
description: 旋转编码器的原理和实现代码
tags: 
  - STM32
  - ESP32
  - 中断
  - 编码器
---

# 📝 旋转编码器全平台通识笔记：从原理到实战
![首图](/images/c-lang/EncoderPrinciple/headphoto.png)
## 第一部分：物理原理 —— A 相和 B 相的赛跑

普通的按键只有两个引脚（通或断），但旋转编码器有三个关键引脚：​**A、B、GND**​。

编码器内部其实有两个开关（或者光栅），我们叫它 **A相** 和 ​**B相**​。

### 1. 核心机制：A 和 B 的“抢跑”游戏

它们的设计非常巧妙：这两个开关在物理位置上**不是**完全对齐的，而是错开了一点点（90度相位差）。

**🏃‍♂️ 形象比喻：窄门赛跑**

这就好比两个人（小A 和 小B）并排过一道窄门，但 ​**小A 总是站得比 小B 靠前一步**​。

* **当你顺时针（CW）转动时：**
  * ​**现象**​：小A 先挤过门碰到开关，小B 紧随其后。
  * ​**波形**​：A 的电平先变高，B 随后变高。
  * ​**口诀**​：A 领跑 B。
* **当你逆时针（CCW）转动时：**
  * ​**现象**​：因为你反着转，原本在后面的 **小B** 反而变成了“前面”那个人。
  * ​**波形**​：B 先变高，A 随后变高。
  * ​**口诀**​：B 领跑 A。


---

## 第二部分：STM32 硬件定时器的“魔法”

单片机怎么知道谁在领跑？

STM32 不需要你写代码去死盯着电平判断“谁先变高”，它内部的定时器（Timer）里有一个专门的硬件电路，叫 ​**正交解码器 (Quadrature Decoder)**​。

它会 24 小时监控 A 和 B 的引脚：

*  监控到 **A 领跑 B** → 自动让硬件计数器 **+1** (0, 1, 2, 3...)
*  监控到 **B 领跑 A** → 自动让硬件计数器 **-1** (3, 2, 1, 0...)


### 📋 哪些 STM32 芯片支持这个功能？

**结论：几乎所有 STM32 都支持。**

只要芯片带有 **通用定时器 (General Purpose Timers)** 或 ​**高级定时器 (Advanced Timers)**​，基本都具备编码器接口模式。

* ​**完全支持**​：
  * ​**STM32F1 系列**​（如 F103）：TIM1 \~ TIM5, TIM8。
  * ​**STM32F4 系列**​（如 F401/F411）：TIM1 \~ TIM5, TIM8 等。
  * ​**新系列**​：STM32G0, G4, L4, H7 等所有通用定时器。
* ​**部分受限**​：
  * ​**STM32F0 系列**​：主要定时器支持，但部分简易定时器（如 TIM6, TIM7）仅用于内部计数，不支持编码器接口。

> ​**✅ 选型建议**​：查看数据手册，确认定时器功能描述带 **"Quadrature (incremental) encoder interface"** 字样即可。

---

## 第三部分：跨平台开发策略 (ESP32 与其他 MCU)

如果不只是用 STM32，换成了 ESP32 或者简单的 Arduino (AVR)，该怎么处理编码器？

### 1. ESP32：也有“硬件魔法” (PCNT)

ESP32 不使用普通的定时器来做编码器解码，它有一个更强大的专用外设，叫做 ​**PCNT (Pulse Counter，脉冲计数器)**​。

* ​**原理**​：PCNT 是专门设计用来处理高频脉冲信号的硬件单元。它可以配置成“正交模式”，功能和 STM32 的定时器编码器模式一模一样。
* ​**优势**​：解码过程完全由硬件完成，​**不占用 CPU 资源**​。即使 Wi-Fi 正在满负荷工作，编码器读数也不会丢步。

*(图注：ESP32 的 PCNT 模块内部拥有专门的相位检测和脉冲计数单元)*

### 2. 普通 MCU (如 Arduino Uno/51单片机)：使用“中断法”

对于没有专用硬件解码器的 MCU，必须用软件方式模拟，通常使用 ​**外部中断 (External Interrupt / EXTI)**​。

* ​**实现逻辑**​：
  1. 将 A 相配置为中断触发（如下降沿）。
  2. 在中断函数中检测 B 相电平：
     * B 为 高 → 顺时针。
     * B 为 低 → 逆时针。
* ​**⚠️ 风险警示**​：
  * ​**中断风暴**​：高速旋转或信号抖动可能引发每秒数千次中断，导致 CPU 卡死。
  * ​**必须滤波**​：一定要配合硬件电容滤波，否则数值会乱跳。

> ​**🚀 黄金法则**​：**有硬件解码器（STM32 Timer / ESP32 PCNT）一定要用硬件的！** 只有在迫不得已时才用外部中断。

---

## 第四部分：通用软件算法 —— “环形世界”与“加速度”

无论你用 STM32 还是 ESP32，底层算出位置后，上层应用逻辑是通用的。

### 1. 环形计数逻辑 (处理溢出)

硬件计数器（CNT）通常是一个闭环（如 16 位计数器：0 \~ 65535）。

* ​**正向溢出**​：从 65535 + 1 → 0
* ​**反向溢出**​：从 0 - 1 → 65535

​**算法思路**​：

计算 `diff = Current - Last`。

* 如果 `diff` 是个极大的负数（如 -65000），说明发生了正向溢出 → 判定为 ​**正转**​。
* 如果 `diff` 是个极大的正数（如 +65000），说明发生了反向溢出 → 判定为 ​**反转**​。
![环形计数器的溢出与下溢示意图](/images/c-lang/EncoderPrinciple/Ringcounter.png)

*(图注：展示 0 和 65535 之间的跳变关系，解释为什么差值会变成巨大负数)*

### 2. 加速度/速度算法 (手感优化)

为了实现“转得快变多，转得慢变少”，引入 ​**时间戳**​。

* ​**原理公式**​：`Velocity = Δ Position / Δ Time`*(即：速度 = 位移变化量 / 时间间隔)*
* ​**通用代码逻辑**​：
  1. ​**记录时间**​：每次检测到 `diff != 0` 时，获取系统时间 `Now = GetTimeMs()`。
  2. ​**算间隔**​：`interval = Now - Last_Time`。
  3. ​**定档位**​：
     * `interval < 50ms` (疯转) → `Step = 100` (粗调)。
     * `interval > 50ms` (慢拧) → `Step = 10` (微调)。
  4. ​**更新**​：`Last_Time = Now`。

---

## 💡 总结

1. ​**物理层**​：依靠 A/B 相位差 90 度来区分方向（A领跑 vs B领跑）。
2. ​**硬件选型**​：
   * ​**STM32**​：找带 "Encoder Interface" 的定时器（绝大多数都有）。
   * ​**ESP32**​：使用 "PCNT" 脉冲计数器硬件。
   * ​**其他**​：没有硬件单元时，使用“外部中断”，但要注意 CPU 负载。
3. ​**软件逻辑**​：无论硬件怎么变，上层的 **溢出处理** 和 **加速度算法** 是通用的。
