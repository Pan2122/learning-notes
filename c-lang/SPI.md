---
layout: doc
title: SPI 协议底层逻辑与传感器实战
description: SPI 协议底层逻辑与传感器实战 (以 BMI160 为例)
tags: 
  - STM32
  - BMI160
  - SPI
---

## 📡 SPI 协议底层逻辑与传感器实战 (以 BMI160 为例)

### 前置基础：

SPI (Serial Peripheral Interface) 是一种 **同步**、**全双工**、**主从架构** 的串行通信协议。理解它的物理连线，是所有底层驱动开发和排障的基础。

标准的 SPI 总线由 4 根线组成：

* **SCK / SCL** (Serial Clock)：时钟线。整个系统的“心脏起搏器”，永远由 **主机 (Master, 即 STM32)** 产生和控制。没有节拍，数据就绝对不会流动。
* **MOSI** (Master Out Slave In)：主机输出，从机输入。数据从单片机流向传感器。
* **MISO** (Master In Slave Out)：主机输入，从机输出。数据从传感器流向单片机。
* **CS / SS / CSB** (Chip Select)：片选线。SPI 总线上可以挂载很多个传感器，单片机想跟谁说话，就把对应传感器的片选线 **拉低**（通常是低电平有效）。没被选中的传感器会主动断开 MISO 引脚（高阻态），绝不插嘴。

### 1. 读懂数据手册 (DataSheet) 的四大密码

* **引脚视角 Pinout**：Input/Output 永远以 Sensor（从机）为第一视角。
* `SDA / SDI` (Serial Data Input)：从机收，接主机的 **MOSI**。
* `SDO` (Serial Data Output)：从机发，接主机的 **MISO**。
* **通信模式 CPOL & CPHA**：
* BMI160 支持模式 `00` 和 `11`。本质上，这两种模式都是在时钟的 **上升沿 (Rising Edge)** 采样数据。
* *AE 习惯*：配置为 `CPOL=High, CPHA=2 Edge`（平时时钟拉高，抗干扰更好）。杜邦线连接时，SPI 速率务必降至 5MHz 以下。
* **读写标志 Read/Write bit**：最高位 MSB 决定方向。读为 1，写为 0。
* **闭环验证 Chip ID**：点亮新芯片的第一步，永远是去读它的固定身份证号（如 `0x00` 地址预期返回 `0xD1`），以验证硬件连线与 SPI 时序是否完美。

### 2. 深入：位掩码 (Bit Mask) 与读写操作

在用 C 语言组装 SPI 发送的寄存器地址时，必须使用位操作：

* **读指令**：`reg_addr | 0x80`
* `0x80` 的二进制是 `1000 0000`，将其用按位或（`|`），将最高位强行置 `1`，其余 7 位地址原样保留。
* **写指令**：`reg_addr & 0x7F`
* **深度解析**：`0x7F` 的二进制是 `0111 1111`。按位与（`&`）时，最高位的 `0` 会强行抹除原本的读写标志；而后面的七个 `1` 相当于一个保护罩，任何数 `& 1` 都等于原值，从而确保真实的 7 位寄存器地址不会被破坏。

### 3. 深入：SPI 的“移位寄存器”本质与 Dummy Byte

### 🧩 核心知识点：SPI 是一扇“旋转门”

在写代码之前，你必须明白 SPI 在物理层是怎么交换数据的。 SPI 是全双工的移位寄存器，可以把它想象成一扇​**两人宽的旋转门**​。

* 当主机（STM32）想把一个字节“推”进旋转门发给从机时，必然会把从机里的一个字节“挤”出来。
* ​如果你只想**读**数据，你也必须假装**写**一个无意义的垃圾数据（通常叫 Dummy Byte，比如 `0xFF` 或 `0x00`）进去，才能把传感器里的真实数据给“挤”出来并接收到。

* **核心原理**：SPI 的数据收发是在一个环形的传送带（移位寄存器）上进行的。**发 1 个字节，必然同时收 1 个字节**。
* **时钟垄断**：时钟线（SCK）的控制权完全在主机（STM32）手中。
* **挤数据的艺术**：
* 步骤 1：主机发送 `寄存器地址`。此时时钟转动 8 次，地址被推入传感器，同时传感器回传一个 **无意义的旧数据**（丢弃不用）。传感器收到地址后，将真实数据准备在自己的传送带上。
* 步骤 2：主机必须发送一个 **Dummy Byte** (垃圾数据，如 0xFF)。这是为了提供时钟节拍，强行让主机的传送带再次转动，从而把传感器准备好的 **真实数据给挤回主机**。

因此，在 STM32 的 HAL 库中，我们最常用、也最稳妥的函数不是单向的 Transmit 或 Receive，而是同时收发的 ​`HAL_SPI_TransmitReceive()`。

### 4. 深入：BMI160 的“上升沿”锁定机制 (暗坑)

* **现象**：BMI160 上电默认处于 I2C 模式。根据手册，它需要检测到 CSB（片选）引脚产生一次 **从低到高的上升沿**，才会切换并锁定到 SPI 模式。
* **解密**：CubeMX 在生成 GPIO 初始化代码时，如果将 CS 引脚配置为默认 `High`，单片机上电执行初始化的一瞬间，引脚电平从浮空猛增到 3.3V，这个物理变化恰好为传感器提供了一个完美的上升沿。
* **鲁棒性建议**：为防止软复位导致引脚电平未发生跳变，推荐在代码初始化阶段，显式地加上“假动作”：

```c
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET); // 拉低
HAL_Delay(5);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);   // 强制制造一次明确的上升沿
HAL_Delay(50);
```

